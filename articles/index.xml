<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Articles on Jare&#39;s Blog</title>
    <link>https://thejare.github.io/articles/</link>
    <description>Recent content in Articles on Jare&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 09 Jul 2012 00:35:38 +0000</lastBuildDate>
    <atom:link href="https://thejare.github.io/articles/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Articles</title>
      <link>https://thejare.github.io/articles/</link>
      <pubDate>Mon, 09 Jul 2012 00:35:38 +0000</pubDate>
      
      <guid>https://thejare.github.io/articles/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.iguanademos.com/Jare/docs/html5/Lessons/&#34;&gt;HTML5/Canvas Game Lessons&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;main-loop-with-fixed-time-steps&#34;&gt;Fixed Timestep Loop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;loadlibrary-getprocaddress-fun&#34;&gt;DLL / Macro Tricks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;init-end&#34;&gt;Init / End Protocol&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;dll-interfaces&#34;&gt;DLL Interfaces&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;rectangle-packing-code&#34;&gt;Rectangle Packer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Praetorians DevDiary - sadly, was hosted in GameSpy and vanished one day&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;reducing-game-load-times&#34;&gt;Reducing Game Load Times&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;positional-printf&#34;&gt;Positional Printf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Rectangle Packing Code</title>
      <link>https://thejare.github.io/articles/rectangle-packing-code/</link>
      <pubDate>Sun, 25 Sep 2011 02:17:22 +0000</pubDate>
      
      <guid>https://thejare.github.io/articles/rectangle-packing-code/</guid>
      <description>&lt;p&gt;Note: this article first appeared as a &lt;a href=&#34;http://www.flipcode.com/cgi-bin/msg.cgi?showThread=COTD-RectPlacement&amp;amp;#038;forum=cotd&amp;amp;#038;id=-1&#34;&gt;Tip Of The Day&lt;/a&gt; in &lt;a href=&#34;http://www.flipcode.com&#34;&gt;Flipcode&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You have a bunch of rectangular pieces. You need to arrange them in a rectangular surface so that they don&amp;rsquo;t overlap, keeping the total area of the rectangle as small as possible. This is fairly common when arranging characters in a bitmapped font, lightmaps for a 3D engine, and I guess other situations as well.&lt;/p&gt;

&lt;p&gt;The idea of this algorithm is that, as we add rectangles, we can pre-select &amp;ldquo;interesting&amp;rdquo; places where we can try to add the next rectangles. For optimal results, the rectangles should be added in order. I initially tried using area as a sorting criteria, but it didn&amp;rsquo;t work well with very tall or very flat rectangles. I then tried using the longest dimension as a selector, and it worked much better. So much for intuition &amp;#8230;&lt;/p&gt;

&lt;p&gt;These &amp;ldquo;interesting&amp;rdquo; places are just to the right and just below the currently added rectangle. The first rectangle, obviously, goes at the top left, the next one would go either to the right or below this one, and so on. It is a weird way to do it, but it seems to work very nicely.&lt;/p&gt;

&lt;p&gt;The way we search here is fairly brute-force, the fact being that for most off-line purposes the performance seems more than adequate. I have generated a japanese font with around 8500 characters and all the time was spent generating the bitmaps.&lt;/p&gt;

&lt;p&gt;Also, for all we care, we could grow the parent rectangle in a different way than power of two. It just happens that power of 2 is very convenient for graphics hardware textures.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;d be interested in hearing of other approaches to this problem. Make sure to post them on &lt;a href=&#34;http://www.flipcode.com&#34;&gt;http://www.flipcode.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;File: RectPlacement.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// --------------------------------------------------------------------------------
// Name        : RectPlacement.h
// Description : A class that allocates subrectangles into power-of-2 rectangles
//               (C) Copyright 2000-2002 by Javier Arevalo
//               This code is free to use and modify for all purposes
// --------------------------------------------------------------------------------

#ifndef _RECT_PLACEMENT_H_
#define _RECT_PLACEMENT_H_


#include &amp;lt;vector&amp;gt;

// --------------------------------------------------------------------------------
// --------------------------------------------------------------------------------

class CRectPlacement
{
  public:

    // Helper classes
    struct TPos
    {
      int x, y;

      TPos() { }
      TPos(int _x, int _y): x(_x), y(_y) { }

      bool operator ==(const TPos &amp;amp;p) const { return x == p.x &amp;amp;&amp;amp; y == p.y; }
    };

    struct TRect: public TPos
    {
      int w, h;

      TRect() { }
      TRect(int _x, int _y, int _w, int _h): TPos(_x, _y), w(_w &amp;gt; 0? _w : 0), h(_h &amp;gt; 0? _h : 0) { }

      bool Contains   (const TPos &amp;amp;p)  const { return (p.x &amp;gt;= x &amp;amp;&amp;amp; p.y &amp;gt;= y &amp;amp;&amp;amp;
                                                       p.x &amp;lt; (x+w) &amp;amp;&amp;amp; p.y &amp;lt; (y+h)); }
      bool Contains   (const TRect &amp;amp;r) const { return (r.x &amp;gt;= x &amp;amp;&amp;amp; r.y &amp;gt;= y &amp;amp;&amp;amp;
                                                       (r.x+r.w) &amp;lt;= (x+w) &amp;amp;&amp;amp; (r.y+r.h) &amp;lt;= (y+h)); }
      bool Intersects (const TRect &amp;amp;r) const { return w &amp;gt; 0 &amp;amp;&amp;amp; h &amp;gt; 0 &amp;amp;&amp;amp; r.w &amp;gt; 0 &amp;amp;&amp;amp; r.h &amp;gt; 0 &amp;amp;&amp;amp;
                                                      ((r.x+r.w) &amp;gt; x &amp;amp;&amp;amp; r.x &amp;lt; (x+w) &amp;amp;&amp;amp;
                                                       (r.y+r.h) &amp;gt; y &amp;amp;&amp;amp; r.y &amp;lt; (y+h)); }

    //  Greater rect area. Not as good as the next heuristic
    //  static bool Greater(const TRect &amp;amp;a, const TRect &amp;amp;b) { return a.w*a.h &amp;gt; b.w*b.h; }

      // Greater size in at least one dim.
      static bool Greater(const TRect &amp;amp;a, const TRect &amp;amp;b) { return (a.w &amp;gt; b.w &amp;amp;&amp;amp; a.w &amp;gt; b.h) ||
                                                                   (a.h &amp;gt; b.w &amp;amp;&amp;amp; a.h &amp;gt; b.h); }
    };

    // ---------------------

    typedef std::vector&amp;lt;TPos&amp;gt;  CPosArray;
    typedef std::vector&amp;lt;TRect&amp;gt; CRectArray;

    // ---------------------

    CRectPlacement()                    { Init(); }
    ~CRectPlacement()                   { End(); }

    void      Init    (int w = 1, int h = 1);
    void      End     ();
    bool      IsOk    ()                      const { return m_size.w &amp;gt; 0; }

    int       GetW    ()                      const { return m_size.w; }
    int       GetH    ()                      const { return m_size.h; }
    long      GetArea ()                      const { return m_area; }
    long      GetTotalArea ()                 const { return m_size.w*m_size.h; }

    bool AddAtEmptySpotAutoGrow (TRect *pRect, int maxW, int maxH);

  private:
    TRect       m_size;
    CRectArray  m_vRects;
    CPosArray   m_vPositions;
    long        m_area;

    // ---------------------

    bool IsFree                 (const TRect &amp;amp;r) const;
    void AddPosition            (const TPos &amp;amp;p);
    void AddRect                (const TRect &amp;amp;r);
    bool AddAtEmptySpot         (TRect &amp;amp;r);
};


#endif //_RECT_PLACEMENT_H_
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;File: RectPlacement.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// ----------------------------------------------------------------------------------------
// Name        : RectPlacement.cpp
// Description : A class that fits subrectangles into a power-of-2 rectangle
//               (C) Copyright 2000-2002 by Javier Arevalo
//               This code is free to use and modify for all purposes
// ----------------------------------------------------------------------------------------

/*
  You have a bunch of rectangular pieces. You need to arrange them in a 
  rectangular surface so that they don&#39;t overlap, keeping the total area of the 
  rectangle as small as possible. This is fairly common when arranging characters 
  in a bitmapped font, lightmaps for a 3D engine, and I guess other situations as 
  well.

  The idea of this algorithm is that, as we add rectangles, we can pre-select 
  &amp;quot;interesting&amp;quot; places where we can try to add the next rectangles. For optimal 
  results, the rectangles should be added in order. I initially tried using area 
  as a sorting criteria, but it didn&#39;t work well with very tall or very flat 
  rectangles. I then tried using the longest dimension as a selector, and it 
  worked much better. So much for intuition...

  These &amp;quot;interesting&amp;quot; places are just to the right and just below the currently 
  added rectangle. The first rectangle, obviously, goes at the top left, the next 
  one would go either to the right or below this one, and so on. It is a weird way 
  to do it, but it seems to work very nicely.

  The way we search here is fairly brute-force, the fact being that for most off-
  line purposes the performance seems more than adequate. I have generated a 
  japanese font with around 8500 characters and all the time was spent generating 
  the bitmaps.

  Also, for all we care, we could grow the parent rectangle in a different way 
  than power of two. It just happens that power of 2 is very convenient for 
  graphics hardware textures.

  I&#39;d be interested in hearing of other approaches to this problem. Make sure
  to post them on http://www.flipcode.com
*/

#include &amp;quot;RectPlacement.h&amp;quot;

// --------------------------------------------------------------------------------
// Name        : 
// Description : 
// --------------------------------------------------------------------------------
void CRectPlacement::Init    (int w, int h)
{
  End();
  m_size = TRect(0, 0, w, h);
  m_vPositions.push_back(TPos(0,0));
  m_area = 0;
}


// --------------------------------------------------------------------------------
// Name        : 
// Description : 
// --------------------------------------------------------------------------------
void CRectPlacement::End     ()
{
  m_vPositions.clear();
  m_vRects.clear();
  m_size.w = 0;
}

// --------------------------------------------------------------------------------
// Name        : IsFree
// Description : Check if the given rectangle is partially or totally used
// --------------------------------------------------------------------------------
bool CRectPlacement::IsFree (const TRect &amp;amp;r) const
{
  if (!m_size.Contains(r))
    return false;
  for (CRectArray::const_iterator it = m_vRects.begin();
       it != m_vRects.end();
       ++it)
    if (it-&amp;gt;Intersects(r))
      return false;
  return true;
}


// --------------------------------------------------------------------------------
// Name        : AddPosition
// Description : Add new anchor point
// --------------------------------------------------------------------------------
void CRectPlacement::AddPosition    (const TPos &amp;amp;p)
{
  // Try to insert anchor as close as possible to the top left corner
  // So it will be tried first
  bool bFound = false;
  CPosArray::iterator it;
  for (it = m_vPositions.begin();
       !bFound &amp;amp;&amp;amp; it != m_vPositions.end();
       ++it)
  {
    if (p.x+p.y &amp;lt; it-&amp;gt;x+it-&amp;gt;y)
      bFound = true;
  }
  if (bFound)
    m_vPositions.insert(it, p);
  else

    m_vPositions.push_back(p);
}

// --------------------------------------------------------------------------------
// Name        : AddRect
// Description : Add the given rect and updates anchor points
// --------------------------------------------------------------------------------
void CRectPlacement::AddRect  (const TRect &amp;amp;r)
{
  m_vRects.push_back(r);
  m_area += r.w*r.h;

  // Add two new anchor points
  AddPosition(TPos(r.x, r.y+r.h));
  AddPosition(TPos(r.x+r.w, r.y));
}

// --------------------------------------------------------------------------------
// Name        : AddAtEmptySpot
// Description : Add the given rectangle
// --------------------------------------------------------------------------------
bool CRectPlacement::AddAtEmptySpot   (TRect &amp;amp;r)
{
  // Find a valid spot among available anchors.

  bool bFound = false;
  CPosArray::iterator it;
  for (it = m_vPositions.begin();
       !bFound &amp;amp;&amp;amp; it != m_vPositions.end();
       ++it)
  {
    TRect Rect(it-&amp;gt;x, it-&amp;gt;y, r.w, r.h);

    if (IsFree(Rect))
    {
      r = Rect;
      bFound = true;
      break; // Don&#39;t let the loop increase the iterator.
    }
  }
  if (bFound)
  {
    // Remove the used anchor point
    m_vPositions.erase(it);

    // Sometimes, anchors end up displaced from the optimal position
    // due to irregular sizes of the subrects.
    // So, try to adjut it up &amp;amp; left as much as possible.
    for (int x = 1; x &amp;lt;= r.x; x++)
      if (!IsFree(TRect(r.x - x, r.y, r.w, r.h)))
        break;
    for (int y = 1; y &amp;lt;= r.y; y++)
      if (!IsFree(TRect(r.x, r.y - y, r.w, r.h)))
        break;
    if (y &amp;gt; x)
      r.y -= y-1;
    else

      r.x -= x-1;
    AddRect(r);
  }
  return bFound;
}


// --------------------------------------------------------------------------------
// Name        : AddAtEmptySpotAutoGrow
// Description : Add a rectangle of the given size, growing our area if needed
//               Area grows only until the max given.
//               Returns the placement of the rect in the rect&#39;s x,y coords
// --------------------------------------------------------------------------------

bool CRectPlacement::AddAtEmptySpotAutoGrow   (TRect *pRect, int maxW, int maxH)
{
  if (pRect-&amp;gt;w &amp;lt;= 0)
    return true;

  int orgW = m_size.w;
  int orgH = m_size.h;

  // Try to add it in the existing space
  while (!AddAtEmptySpot(*pRect))
  {
    int pw = m_size.w;
    int ph = m_size.h;

    // Sanity check - if area is complete.
    if (pw &amp;gt;= maxW &amp;amp;&amp;amp; ph &amp;gt;= maxH)
    {
      m_size.w = orgW;
      m_size.h = orgH;
      return false;
    }

    // Try growing the smallest dim
    if (pw &amp;lt; maxW &amp;amp;&amp;amp; (pw &amp;lt; ph || ((pw == ph) &amp;amp;&amp;amp; (pRect-&amp;gt;w &amp;gt;= pRect-&amp;gt;h))))
      m_size.w = pw*2;
    else
      m_size.h = ph*2;
    if (AddAtEmptySpot(*pRect))
      break;

    // Try growing the other dim instead
    if (pw != m_size.w)
    {
      m_size.w = pw;
      if (ph &amp;lt; maxW)
        m_size.h = ph*2;
    }
    else
    {
      m_size.h = ph;
      if (pw &amp;lt; maxW)
        m_size.w = pw*2;
    }

    if (pw != m_size.w || ph != m_size.h)
      if (AddAtEmptySpot(*pRect))
        break;

    // Grow both if possible, and reloop.
    m_size.w = pw;
    m_size.h = ph;
    if (pw &amp;lt; maxW)
      m_size.w = pw*2;
    if (ph &amp;lt; maxH)
      m_size.h = ph*2;
  }
  return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;File: Test.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// ----------------------------------------------------------------------------------------
// Name        : Test.cpp
// Description : Test the RectPlacement class
//               (C) Copyright 2000-2002 by Javier Arevalo
//               This code is free to use and modify for all purposes
// ----------------------------------------------------------------------------------------

#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;algorithm&amp;gt;

#include &amp;quot;RectPlacement.h&amp;quot;

#define MAX_TEXTURE_W 256
#define MAX_TEXTURE_H 256

#define NUM_SUBRECTS  500
#define MIN_SUBRECT    15
#define MAX_SUBRECT    50


// --------------------------------------------------------------------------------
// --------------------------------------------------------------------------------

struct TSubRect: public CRectPlacement::TRect
{
  int n;      // Original index of this subrect, before sorting
  int nTex;   // Texture in which this subrect will be placed.

  TSubRect() { }
  TSubRect(int _w, int _h, int _n): TRect(0, 0, _w, _h), n(_n), nTex(0) { }
};

// --------------------------------------------------------------------------------
// --------------------------------------------------------------------------------

typedef std::vector&amp;lt;TSubRect&amp;gt;       CSubRectArray;
typedef std::vector&amp;lt;CRectPlacement&amp;gt; CTextureArray;

// --------------------------------------------------------------------------------
// Name        : CreateLetters
// Description : Here&#39;s where you calculate your rectangles,
// --------------------------------------------------------------------------------

void CreateLetters  (CSubRectArray &amp;amp;vecSubRects)
{
  vecSubRects.clear();

  // Let&#39;s just fill this with random stuff
  for (int i = 0; i &amp;lt; NUM_SUBRECTS; i++)
    vecSubRects.push_back(TSubRect((rand() % MAX_SUBRECT) + MIN_SUBRECT,
                                   (rand() % MAX_SUBRECT) + MIN_SUBRECT, i));
}

// --------------------------------------------------------------------------------
// Name        : CreateTextures
// Description : Create array of textures containing all subrects
// --------------------------------------------------------------------------------
void CreateTextures (CTextureArray &amp;amp;vecTextures, CSubRectArray &amp;amp;vecSubRects, int maxTexW, int maxTexH)
{
  // Sort the subRects based on dimensions, larger dimension goes first.
  std::sort(vecSubRects.begin(), vecSubRects.end(), CRectPlacement::TRect::Greater);

  // Generate the first texture
  vecTextures.clear();
  vecTextures.push_back(CRectPlacement());

  // Add all subrects
  for (CSubRectArray::iterator it = vecSubRects.begin();
       it != vecSubRects.end();
       ++it)
  {
    // We make sure we leave one pixel between subrects, so texels don&#39;t bleed with bilinear.
    CRectPlacement::TRect r(0, 0, it-&amp;gt;w+1, it-&amp;gt;h+1);

    // If an existing texture has actual space
    bool bPlaced = false;
    for (int i = 0; !bPlaced &amp;amp;&amp;amp; i &amp;lt; vecTextures.size(); i++)
    {
      bPlaced = vecTextures[i].AddAtEmptySpotAutoGrow(&amp;amp;r, maxTexW, maxTexH);
      if (bPlaced)
        it-&amp;gt;nTex = i;
    }

    // Try starting a new texture and fit the rect in there
    if (!bPlaced)
    {
      vecTextures.push_back(CRectPlacement());
      bPlaced = vecTextures[vecTextures.size()-1].AddAtEmptySpotAutoGrow(&amp;amp;r, maxTexW, maxTexH);
      if (bPlaced)
        it-&amp;gt;nTex = vecTextures.size()-1;
      else
        printf(&amp;quot;ERROR: Subrect is too big to fit in texture!&amp;quot;, it-&amp;gt;w, it-&amp;gt;h);
    }

    // If correctly placed in a texture, the coords are returned in r.x and r.y
    // Store them.
    if (bPlaced)
    {
      it-&amp;gt;x = r.x;
      it-&amp;gt;y = r.y;
    }
  }
}

// --------------------------------------------------------------------------------
// Name        : main
// Description : heh
// --------------------------------------------------------------------------------
int main()
{
  CTextureArray vecTextures;
  CSubRectArray vecSubRects;

  CreateLetters(vecSubRects);
  CreateTextures(vecTextures, vecSubRects, MAX_TEXTURE_W, MAX_TEXTURE_H);

  {
    for (CSubRectArray::const_iterator it = vecSubRects.begin();
         it != vecSubRects.end();
         ++it)
    {
      printf(&amp;quot;Subrect %d (originally %d), size %dx%d, goes into texture %d at pos %d,%d\n&amp;quot;,
             it - vecSubRects.begin(), it-&amp;gt;n, it-&amp;gt;w, it-&amp;gt;h, it-&amp;gt;nTex, it-&amp;gt;x, it-&amp;gt;y);
    }
  }

  printf(&amp;quot;Created a total of %d textures\n&amp;quot;, vecTextures.size());
  {
    for (CTextureArray::const_iterator it = vecTextures.begin();
         it != vecTextures.end();
         ++it)
    {
      printf(&amp;quot;  Texture %d, size %dx%d, Coverage %d / %d (%d%%)\n&amp;quot;,
             it - vecTextures.begin(), it-&amp;gt;GetW(), it-&amp;gt;GetH(),
             it-&amp;gt;GetArea(), it-&amp;gt;GetTotalArea(), it-&amp;gt;GetArea()*100/it-&amp;gt;GetTotalArea());
    }
  }
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Reducing Game Load Times</title>
      <link>https://thejare.github.io/articles/reducing-game-load-times/</link>
      <pubDate>Sun, 25 Sep 2011 02:09:45 +0000</pubDate>
      
      <guid>https://thejare.github.io/articles/reducing-game-load-times/</guid>
      <description>&lt;p&gt;Note: this article was originally found at &lt;a href=&#34;http://www.flipcode.com/cgi-bin/msg.cgi?showThread=Tip-ReducingGameLoadTimes&amp;amp;#038;forum=totd&amp;amp;#038;id=-1&#34;&gt;Tip Of The Day&lt;/a&gt; in &lt;a href=&#34;http://www.flipcode.com&#34;&gt;Flipcode&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Sebastian Wagner started an interesting thread on this topic, but my response got long enough that I think a totd is more appropriate.&lt;/p&gt;

&lt;p&gt;I will explain some of the things we did in Commandos 2 and Praetorians in order to speed up load times. Notice that in Praetorians, some levels will load in one or two seconds, with five seconds maybe for the largest, so for the most part the load time.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Have a correct mindset: Windows&amp;rsquo; memory allocation or file handling are not a problem, the slow DVD reads and seek times are not a problem. The way YOU use those things can be a problem, however. They are just part of the environment you have to work with.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Design the file formats that your game loads with engine speed in mind. This usually means, lay out in a piece of paper what the engine needs and the order in which it needs it, and then turn that into a file format. NEVER use your tool&amp;rsquo;s file format for the actual game. We&amp;rsquo;re using XML for simple data files in our next engine, but I&amp;rsquo;m curious to see if we will run into trouble with speed.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Avoid any processing during loads, that process can probably be done beforehand and stored.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Have a centralized FileSystem module in your core engine, and use that to access files. NEVER allow direct access to files using other means.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Ensure that you fseek() as little as possible, and don&amp;rsquo;t have to seek backwards at all. Issue a warning on your textlog (you have one, don&amp;rsquo;t you?) every time a seek goes backwards.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Group and compress your datafiles into a pack file; if a file exists outside the packfile, it is used instead, to ease development. Praetorians&amp;rsquo; packfiles are just ZIP files, like Quake&amp;rsquo;s, with (optional) encryption on top. Since you never seek backwards, you can decompress on the fly with a small buffer (we used 32K) without worries. Of course, decompressing must be faster than loading, so don&amp;rsquo;t use a compressor with long decompression times. For example, some of our graphics are DXTC compressed even if we don&amp;rsquo;t actually use DXTC textures.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Ensure that your pack files support uncompressed, unencrypted files with as little processing and memcpy&amp;rsquo;ing around as possible. This will allow you to do seamless loading on the background. In Praetorians, we do not load any sounds until the level is loaded and playable, at that point we start a background sound loading process with priorities, requests and all that stuff (this is a topic on its own).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Avoid loading from several files at the same time. For example, if you have a file that contains a list of sounds, load the file, then iterate the list to load the actual sounds, and then drop the list. This helps with hard drives, but it is absolutely crucial for DVDs.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Add a little filename logger so you can see in which order are files being loaded, so you can place them consecutively in the packfile and reduce seek times even further.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Consider redundancy in your data files. For the PSX research port of Commandos 2 we started, we needed to load the scenery bitmaps on the fly, so we did a background process to load tiles as the player was scrolling. We quickly saw that for 8-way scrolling, we would typically need to load a new row and a new column of tiles, so we stored the maps twice, one in row-major order and another in column-major order, so we only needed to issue two seeks and two reads. The PSX port of the game was obviously stopped at some point (it was hard enough to cram it into the PS2!!), but this optimization made it into the final game.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Make quick loading speeds a matter of pride. Despite our lighting fast load times, we considered optimizing the load when the level or civilizations you&amp;rsquo;re reloading are already in memory. This was low priority and never got done, but the important thing is that we wanted to go that far. Someone mentioned to me once that long load times helped extend the play hours a game gives you, and reduced the &amp;#8220;quicksave-try-die-retry&amp;#8221; dumbness that some players went into and forced them to actually plan their game actions, but I think this is NOT a good mindset. 🙂&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Profile, profile, profile. Profile both in Release and Debug mode, load from the network, burn your installed game into a CD and load from there as if it was the hard drive. Try the absolutely worst cases: you will be surprised what you find:&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In Praetorians, after putting out the singleplayer game, we noticed that a good 30-50% of our load times were spent searching for the file in the packfile directories. We hadn&amp;rsquo;t noticed this before because our dev machines had most of the data files outside of packfiles, and even with packfiles, the load time was fairly fast in Release mode. However, when one of the guys started running with the final packfiles, he noticed the slower times and did a little profile. With a couple hours&amp;rsquo; work adding a little tree structure to the filename lists, this search time disappeared.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In Commandos: Beyond The Call Of Duty, my last two weeks were spent optimizing code around (I didn&amp;rsquo;t work on the game itself). The two major pieces were save and load times: I was able to cut them in more than half just by profiling and applying common sense! The funkiest point was to find that the progress bar was being updated too frequently, and adding a plain if() saved a ton of time.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Try to do a little work so your loading progress bars actually reflect the time spent: seeing a progress bar jump from 50% to 90% and then staying there for a long time is annoying.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Don&amp;rsquo;t load your levels twice, like the game Sin did. 😉&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All this work will not turn a bad game into a good one, of course, but people will perceive it as more polished, and you will be more ready for console work, where it DOES matter.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Positional Printf</title>
      <link>https://thejare.github.io/articles/positional-printf/</link>
      <pubDate>Sun, 25 Sep 2011 02:01:49 +0000</pubDate>
      
      <guid>https://thejare.github.io/articles/positional-printf/</guid>
      <description>&lt;p&gt;Note: this article was originally found at &lt;a href=&#34;http://www.flipcode.com/cgi-bin/msg.cgi?showThread=COTD-posprintf&amp;amp;#038;forum&amp;amp;#038;forum=cotd&amp;amp;#038;id=-1&#34;&gt;Code Of The Day&lt;/a&gt; in &lt;a href=&#34;http://www.flipcode.com&#34;&gt;Flipcode&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Printf-style formatting is well known, flexible and very useful in general. All the worries about unchecked parameters and so on have proven to be a non-íssue in my experience. However, it lacks parameter positioning, the way .NET allows. Why is this important for games? Any modern game needs to have a good localisation system; most game translators understand printf-style format strings and know what to do with them when they are among the text strings to be localised. There is a subtle kind of localised strings that can&amp;rsquo;t be easily translated most of the times: strings in which parameterized data changes position depending on the language. A good example is the date format, dd/mm/yy as we use in Europe as opposed to the mm/dd/yy format in the US. The format string would be &amp;ldquo;%d/%d/%d&amp;rdquo;, and the call could be something like:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;printf(LTEXT\_DATE\_STRING, day, month, year);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;How would you localise a string like that to the US without modifying the code? Using system locale functions defeats the point I&amp;rsquo;m making; another example are strings like &amp;ldquo;Rick&amp;rsquo;s Bar&amp;rdquo; as opposed to &amp;ldquo;El Bar de Rick&amp;rdquo;, where both &amp;ldquo;Rick&amp;rdquo; and &amp;ldquo;Bar&amp;rdquo; would change positions if they are parameters.&lt;/p&gt;

&lt;p&gt;The function I present here wraps printf with an extension to format specifiers, which allows for parameter placement. In the given example, the US string would be &amp;ldquo;%{1}d/%{0}d/%{2}d&amp;rdquo;, where the number in parenthesis specifies which parameter should be used in that place of the format string. If no placement modifier is included, it assumes the next parameter from the previous format specifier. This way, the function will work fine with regular printf format strings.&lt;/p&gt;

&lt;p&gt;The code will need modifications to be a full-blown function to use in your own application, and is only presented as an example of the technique. Check it, read the comments and modify at will. It is templatized in order to support both 8-bit chars and 16-bit wchar_t strings.&lt;/p&gt;

&lt;p&gt;Caveats:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Asterisks (&amp;rsquo;*&amp;lsquo;) in the format string can&amp;rsquo;t be supported this way.&lt;/li&gt;
&lt;li&gt;It only supports &amp;ldquo;%c&amp;rdquo;, &amp;ldquo;%d&amp;rdquo;, &amp;ldquo;%g&amp;rdquo; and &amp;ldquo;%s&amp;rdquo; format strings (but will work with all format modifiers except the mentioned asterisk). Extending this support is trivial.&lt;/li&gt;
&lt;li&gt;Portions of the code are system-dependent. This example currently works in Microsoft&amp;rsquo;s .NET compiler, but it shouldn&amp;rsquo;t be hard to modify for your own platform.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// -----------------------------------------------
// PositionalPrintfTest.cpp

#define UNICODE
#include &amp;lt;tchar.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

#include &amp;quot;PositionalPrintf.h&amp;quot;

// Try different things with the fancy printf function
int _tmain(int argc, _TCHAR* argv[])
{
  printf(_T(&amp;quot;%s %g %d %c\n&amp;quot;), _T(&amp;quot;Hola&amp;quot;), 3.4f, 34, _T(&#39;3&#39;));

  PositionalPrintf(&amp;quot;%s %g %d %c\n&amp;quot;, &amp;quot;Hola&amp;quot;, 3.4f, 34, &#39;3&#39;);
  PositionalPrintf(L&amp;quot;%s %g %d %c\n&amp;quot;, L&amp;quot;Hola&amp;quot;, 3.4f, 34, L&#39;3&#39;);
  PositionalPrintf(_T(&amp;quot;%s %g %d %c\n&amp;quot;), _T(&amp;quot;Hola&amp;quot;), 3.4f, 34, _T(&#39;3&#39;));

  PositionalPrintf(&amp;quot;%{3}c %g - %{0}s&#39;s %{1}s\n%{3}c %{4}g - El %{1}s de %{0}s&amp;quot;, &amp;quot;Rick&amp;quot;, &amp;quot;Bar&amp;quot;, &#39;S&#39;, &#39;E&#39;, 3.1415f);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// -----------------------------------------------
// PositionalPrintf.h

// Only two versions of this template are instantiated, char and wchar_t
// Any other attempt to use this function will result in a link error.
template&amp;lt;typename T&amp;gt;
void PositionalPrintf(const T *pszFmt, ...);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// -----------------------------------------------
// PositionalPrintf.cpp

#include &amp;lt;stdarg.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

// Templated functions for char/wchar_t operations.
template &amp;lt;typename T&amp;gt; int TempAtoi(const T *p);

template&amp;lt;&amp;gt; int TempAtoi(const char *p) { return atoi(p); }
template&amp;lt;&amp;gt; int TempAtoi(const wchar_t *p) { return _wtoi(p); }

template &amp;lt;typename T&amp;gt; void TempVPrintf(const T *p, va_list va);

template&amp;lt;&amp;gt; void TempVPrintf(const char *p, va_list va)     { vprintf(p, va); }


template&amp;lt;&amp;gt; void TempVPrintf(const wchar_t *p, va_list va)  { vwprintf(p, va); }

// The actual function
template&amp;lt;typename T&amp;gt;
void PositionalPrintf(const T *pszFmt, ...)
{
  enum TParam
  {
    TP_UNK,
    TP_CHAR,
    TP_INT,
    TP_STR,
    TP_FLOAT,
  };
  static const int MAX_PARAMS = 100;

  // Here we store the parameters we should be expecting on the stack


  // We decide this based on the format string.
  int nParams  = 0;
  int nextParam = 0;
  TParam aParams[MAX_PARAMS];

  // Here we store each &#39;%&#39; format element&#39;s data from the format string.
  struct
  {
    TParam param;
    int    pos;
  } aFormats[MAX_PARAMS];
  int nFormats = 0;

  for (int i = 0; i &amp;lt; MAX_PARAMS; ++i)
    aParams[i] = TP_UNK;

  // Scan the format string to detect expected parameters and the way to extract them from the stack.


  bool bError = false;
  for (const T *s = pszFmt; *s; ++s)
  {
    if (*s == T(&#39;%&#39;))
    {
      // Found a format element. First thing to do is identify the position of the parameter
      // on the stack.


      int pos;
      if (*(s+1) == T(&#39;{&#39;))
      {
        // Explicit position modifier
        pos = TempAtoi(s+2);
        nextParam = pos+1;
      }
      else
        pos = nextParam++; // Just se the next position.
      while (*s &amp;amp;&amp;amp; *s != T(&#39;c&#39;) &amp;amp;&amp;amp; *s != T(&#39;d&#39;) &amp;amp;&amp;amp; *s != T(&#39;g&#39;) &amp;amp;&amp;amp; *s != T(&#39;s&#39;))
      {
        // Here we could detect &#39;*&#39; parameters (which won&#39;t work), missing &#39;}&#39;, etc.


        s++;
      }
      if (!*s)
        break;

      if (pos &amp;gt;= MAX_PARAMS)
      {
        // error
        printf(&amp;quot;ERROR! Parameter %d out of range.\n&amp;quot;, pos);
        bError = true;
      }
      else 
      {
        // Identifica el tipo de parámetro que es


        // Aqui podemos extender esto un montón para cubrir todos los tipos de formato
        TParam p;
        if (*s == T(&#39;c&#39;))      p = TP_CHAR;
        else if (*s == T(&#39;d&#39;)) p = TP_INT;
        else if (*s == T(&#39;s&#39;)) p = TP_STR;
        else                   p = TP_FLOAT;

        if (aParams[pos] != TP_UNK &amp;amp;&amp;amp; aParams[pos] != p)
        {
          // error


          printf(&amp;quot;ERROR! Parameter %d used with different format specifiers (%d and %d).\n&amp;quot;, pos, aParams[pos], p);
          bError = true;
        }

        // Store the parameter type to be expected at position &#39;pos&#39; on the stack.
        aParams[pos] = p;
        if (nParams &amp;lt;= pos)
          nParams = pos+1;

        // Store the parameter type and position on the stack, for this format element.
        if (nFormats &amp;gt;= MAX_PARAMS)
        {
          // error


          printf(&amp;quot;ERROR! Too many format elements (%d)!\n&amp;quot;, nFormats);
          bError = true;
        }
        else
        {
          aFormats[nFormats].param = p;
          aFormats[nFormats].pos   = pos;
          nFormats++;
        }
      }
    }
  }

  // Verify that all parameters on the stack are referenced. (optional)
  for (int i = 0; i &amp;lt; nParams; i++)
  {
    if (aParams[i] == TP_UNK)
    {
      // error


      // Benign if we assume that unused parameters are of INT size.
//      printf(&amp;quot;ERROR! Parameter %d undefined.\n&amp;quot;, i);
//      bError = true;
    }
  }
  if (bError)
    return;

  // Build a new format string removing the {n} modifiers
  T szNewFmt[3000];
  {
    T *p = szNewFmt;

    szNewFmt[0] = T(0);

    for (const T *s = pszFmt; *s; s++)
    {
      *p++ = *s;
      if (*s == T(&#39;%&#39;))
      {
        if (*(s+1) == T(&#39;{&#39;))
        {
          s += 2;
          while (*s &amp;amp;&amp;amp; *s != T(&#39;}&#39;))
            s++;
          if (!*s)
            break;
        }
      }
    }
    *p = T(0); // Zero-end the new format string


  }
  
  // Copy the parameters to the parameter buffer in correct order.
  // Here comes the system-dependent part
  char aParamBuf[3000];
  {
    char *p = aParamBuf;

    for (int i = 0; i &amp;lt; nFormats; ++i)
    {
      va_list va;
      va_start(va, pszFmt);

      // Skip stack parameters until the one we&#39;re looking for.


      // System-dependent: assumes that anything that is not of type double is of INT size
      for (int j = 0; j &amp;lt; aFormats[i].pos; ++j)
      {
        if (aParams[j] == TP_FLOAT)
          va_arg(va, double);
        else

          va_arg(va, int);
      }

      // Copy the parameter into the new parameter buffer
      // System-dependent: the size thing again.
      // System-dependent: assumes things about the order in which parameters are stored on the stack.
      if (aParams[j] == TP_FLOAT)
      {
        double d = va_arg(va, double);
        memcpy(p, &amp;amp;d, sizeof(d));
        p += sizeof(d);
      }
      else

      {
        int d = va_arg(va, int);
        memcpy(p, &amp;amp;d, sizeof(d));
        p += sizeof(d);
      }
    }
  }

  // System-dependent: assumes that aParamBuf can be cast straight to va_list.
  TempVPrintf(szNewFmt, (va_list)aParamBuf);
}

// Instantiate the char and wchar_t versions of the function.

template void PositionalPrintf(const char *pszFmt, ...);

template void PositionalPrintf(const wchar_t *pszFmt, ...);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Object Initialization and Finalization Protocol</title>
      <link>https://thejare.github.io/articles/init-end/</link>
      <pubDate>Sun, 25 Sep 2011 01:56:32 +0000</pubDate>
      
      <guid>https://thejare.github.io/articles/init-end/</guid>
      <description>&lt;p&gt;Note: this article first appeared as a &lt;a href=&#34;http://www.flipcode.com/cgi-bin/msg.cgi?showThread=Tip-ObjectInitFinal&amp;amp;forum=totd&amp;amp;id=-1&#34;&gt;Tip Of The Day&lt;/a&gt; in &lt;a href=&#34;http://www.flipcode.com/&#34;&gt;Flipcode&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This is a coding procedure we have adopted as standard in all of Pyro Studios projects. The roots of it probably come from the fact that the first Object Oriented language I learned was Borland&amp;rsquo;s Turbo Pascal 5; it didn&amp;rsquo;t have automatic construction or destruction calls, so you had to initialize the instances explicitly. Ok, no big deal, the real benefits were extensible classes and virtual methods.&lt;/p&gt;

&lt;p&gt;Then I arrived to the C++ world, reading who is probably the best writer about C++: Brucke Eckel. All those magic things happening under the hood! Constructors! Virtual multiple inheritance! Templates and Exceptions! WOW. At first I was thinking every new feature was cooler than the previous one. At some point, however, I came to the conclusion that I just had too many features in my hands, and not all of them were good all the time. But how to structure this? I can handle it just by intuition when I&amp;rsquo;m coding at home, but when it comes to a programming team composed of more than ten programmers, intuition is just not there. So I evolved a set of coding standards that would enable more coherence in the code written by a team of people. This is just one of those standards, which I have discussed and refined over time with teammates like Dwight Luetscher, Scott Corley, Terry Wellman, Unai Landa and Jon Beltran de Heredia.&lt;/p&gt;

&lt;p&gt;Any class in a software system will conform to this structure:
Constructor: Does not receive parameters, and its body simply assigns a specific value to one member field.
Destructor: Simply calls the End() member funcion
It will have at least the following member functions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool Init(...);     // Whatever initialization parameters actually needed.
void End();         // No parameters and no return value for finalization.

bool IsOk() const;  // Typically will be inlined.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Init() funcion may have parameters, and the return value is some sort of error code indicating whether the object was properly initialized (error codes are a whole separate topic worth its own tip of the day).&lt;/p&gt;

&lt;p&gt;The End() funcion never gets parameters, which means that the object must remember any potential piece of data necessary for freeing its resources.&lt;/p&gt;

&lt;p&gt;The function IsOk() returns true if the object is correctly initialized and ready for use. It will always return false before the first call to Init(), after a call to End(), or after a call to Init() that returns an error.&lt;/p&gt;

&lt;p&gt;Any of these three functions must be acceptable at any point in time. This means, You may call Init() several times in a row without any memory or resource leakage. You may also call End() succesively without the code attempting any invalid operation.&lt;/p&gt;

&lt;p&gt;Any other member functions may check the IsOk() state before going to perform their operations. In many cases you will want to use assert() to flag as a programming error any attempts to use an object which failed to initialize properly.&lt;/p&gt;

&lt;p&gt;This is a typical implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;---- File InitEndTest.h ----

class CInitEndTest
{
  public:
    CInitEndTest    (): m_bOk(false)   { }
    ~CInitEndTest   ()                 { End(); }

    bool    Init    (parameters);
    void    End     ();
    bool    IsOk    ()           const { return m_bOk; }

    void    DoStuff ();

  private:
    bool    m_bOk;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;---- File InitEndTest.cpp ----

#include &amp;quot;InitEndTest.h&amp;quot;

bool CInitEndTest::Init(parameters)
{
  End();
  // ... perform initializations
  // ... set m_bOk to true if everything goes right.
  return m_bOk;
}

void CInitEndTest::End()
{
  if (m_bOk)
  {
    // Free resources.
    m_bOk = false;
  }
}

void CInitEndTest::DoStuff()
{
  ASSERT(IsOk());
  // Actually do the stuff
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you derive a new class from one that uses this protocol, you should be calling the base&amp;rsquo;s Init() and End() functions at the right places, instead of messing around with the m_bOk member. If you use virtual functions and polymorphic behaviour, then both the destructor and the End() function must be virtual as well (in the base and the derived classes). Supposing the previous example had them properly virtualized, here&amp;rsquo;s an example of derivation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;---- File VirtualTest.h ----

#include &amp;quot;InitEndTest.h&amp;quot;

class CVirtualTest: public CInitEndTest
{
    typedef CInitEndTest inherited;  // To avoid the actual base&#39;s name.

  public:
            CVirtualTest    ()                 { }
    virtual ~CVirtualTest   ()                 { End(); }

            bool    Init    (parameters);
    virtual void    End     ();

  private:
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;---- File VirtualTest.cpp ----

#include &amp;quot;VirtualTest.h&amp;quot;

bool CVirtualTest::Init(parameters)
{
  End();

  // Initialize the base first.  
  if (inherited::Init())
  {
    // ... perform my own initializations
    // ... call inherited::End() if they fail.
  }
  return IsOk();
}

/*virtual*/ void CVirtualTest::End()
{
  if (IsOk())
  {
    // Free my own resources
    // Free the base&#39;s at the end.
    inherited::End();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what&amp;rsquo;s the advantage of limiting the use of the powerful C++ constructor / destructor syntax? Simply, that the initialization and lifespan of an instance are not tied together. This can be useful in many situations when you want to reinitialize a set of objects that are pointed to from many different places in the system, for example textures and lost surfaces in a 3D engine after the user Alt-TABs out and back into your app.&lt;/p&gt;

&lt;p&gt;Thanks to the ASSERT sentences you quickly catch any initializations when a return code was not properly checked. With correct inlining, there is no speed penalty to IsOk() calls. And the construction doesn&amp;rsquo;t fill in any unnecessary fields, making array allocations faster to execute.&lt;/p&gt;

&lt;p&gt;In some situations where you want to keep the memory or code tight, you might use an actual data member to flag initialization, instead of a separate m_bOk member. For example, in a File class wrapper, if you have a FILE *m_pFile member to point to the actual stdio file, then your constructor would set it to NULL and your IsOk() function would compare it to NULL; an array class might use &amp;ldquo;m_numElements == 0&amp;rdquo;, a DirectX wrapper might use &amp;ldquo;m_pDD == NULL&amp;rdquo; and so on.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;So what&amp;rsquo;s the big deal? I have done this already when I figured I needed it.&amp;rdquo; The real advantage lies in the fact that, when you apply this protocol all through a big system, you always have a standard way of checking for the state of an object before you use it. Different programmers don&amp;rsquo;t figure out their own names and code paths, and you can catch missing error checks quickly. As usual, the counterpart is that any simple class already requires writing a few lines of boring &amp;ldquo;bureaucratic&amp;rdquo; code. As time passed, I found myself using this protocol for even the simplest of classes in my own personal projects, and has now become about as standard a part of development as a good Source Control system.&lt;/p&gt;

&lt;p&gt;Note: you may want to dispense of this protocol for classes that are simple data structures with no resource allocation, like math vectors, matrices and such, where initialization is a simple matter of assigning values.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LoadLibrary-GetProcAddress Fun</title>
      <link>https://thejare.github.io/articles/loadlibrary-getprocaddress-fun/</link>
      <pubDate>Sun, 25 Sep 2011 01:56:32 +0000</pubDate>
      
      <guid>https://thejare.github.io/articles/loadlibrary-getprocaddress-fun/</guid>
      <description>&lt;p&gt;Note: this article first appeared as a &lt;a href=&#34;http://www.flipcode.com/cgi-bin/msg.cgi?showThread=Tip-LoadLibraryGetProcAddress&amp;amp;#038;forum=totd&amp;amp;#038;id=-1&#34;&gt;Tip Of The Day&lt;/a&gt; in &lt;a href=&#34;http://www.flipcode.com&#34;&gt;Flipcode&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I explain a macro trick used by the authors of the BASS sound library to help with dynamic loading of the DLL; then I introduce a way to make it even easier to apply. Afterwards I extend the idea with a modified macro + a header file trick which useful by itself. 3 totds in one! 🙂&lt;/p&gt;

&lt;p&gt;Last night, adding the sound library BASS (visit &lt;a href=&#34;http://www.un4seen.com/music/&#34;&gt;http://www.un4seen.com/music/&lt;/a&gt;) to a pet project, I noticed they had added and documented a nice trick to help people who want to load the DLL at runtime instad of static-linking it. The trick is in the way all the functions in the DLL&amp;#8217;s header file bass.h are declared:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;BOOL BASSDEF(BASS_GetDeviceDescription)(int devnum, char **desc)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;i.e. with the macro BASSDEF surrounding the function name. This macro is defined at the beginning:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#ifndef BASSDEF
#define BASSDEF(f) WINAPI f
#endif

// The declaration above is, after the macro substitution, a plain old 
function declaration:
BOOL WINAPI BASS_GetDeviceDescription(int devnum, char **desc);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Normally, if you want to load a DLL at runtime and GetProcAddress() the functions you want, you are forced to declare your own function pointer vars with the right parameter declaration. However, in BASS, when you include the header file, you can simply do&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define BASSDEF(f) (WINAPI *f) // define the functions as pointers
#include &amp;quot;bass.h&amp;quot;

// The declaration above is now interpreted differently:
BOOL (WINAPI *BASS_GetDeviceDescription)(int devnum, char **desc);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and instead of the useless (for dynamic loading) function declarations, you have obtained a list of function pointer variables with the right parameters. Cool! Now it&amp;#8217;s up to you to write:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;BASS_GetDeviceDescription = GetProcAddress(bass, &amp;quot;BASS_GetDeviceDescription&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;for each function you want, and then call BASS_GetDeviceDescription(-1, &amp;amp;pInfo) just like you normally would. What a cool tip of the day, right?&lt;/p&gt;

&lt;p&gt;WRONG! You missed type checking. A C++ compiler will complain that BASS_GetDeviceDescription is of type int (\__stdcall *)(int, char**), while GetProcAddress() returns a int (__stdcall *)(void) value. DAMN! We&amp;#8217;re right where we started because we have to typecast each GetProcAddress separately, and to do so we need the right parameters again.&lt;/p&gt;

&lt;p&gt;Instead of that mess, we can do some weird typecast trickery:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;*(void**)&amp;amp;BASS_GetDeviceDescription=(void*)GetProcAddress(bass, &amp;quot;BASS_GetDeviceDescription&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since we already know the funcptr variables have the correct types (because they come from the official header), we can simply coerce the compiler into treating them as (void*) variables during the assignment, and avoid repeating the function declarations. I ended up using a macro to further simplify things:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define INITBASSF(f) *(void**)&amp;amp;f=(void*)GetProcAddress(bass, #f)

INITBASSF(BASS_Init);
INITBASSF(BASS_Start);
INITBASSF(BASS_Stop);
INITBASSF(BASS_Free);
INITBASSF(BASS_GetInfo);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;#8217;s even more! We still have to write our list of funcptr initializations. Should we forget one, the funcptr variable will be uninitialized, trying to call it may cause major havok. I know this is a minor burden since you will catch most errors right away in a debug build; however, can we automate this further? YES! They could have separated the function declarations into their own header file (without any single-include guards), with the standard BASSDEF macro taking also the parameter declaration as a macro parameter:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Inside &amp;quot;Bass.h&amp;quot;
#define BASSDEF(f,p) WINAPI f p
...
#include &amp;quot;BassFunctions.h&amp;quot;

// BassFunctions.h:
BOOL BASSDEF(BASS_GetDeviceDescription, (int devnum, char **desc));
void BASSDEF(BASS_SetBufferLength, (float length));
//... the rest of the BASSDEF function declarations
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With that little help bit, my MusicPlayer.cpp wrapper file would look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define BASSDEF(f,p) (WINAPI *f) p // define the functions as pointers
#include &amp;quot;Bass.h&amp;quot;
//....
bool CMusicPlayer::Init()
{
   HINSTANCE bass=LoadLibrary(&amp;quot;BASS.DLL&amp;quot;); // load BASS
   if (!bass) return false;

   #undef BASSDEF
   #define BASSDEF(f,p) *(void**)&amp;amp;f=(void*)GetProcAddress(bass, #f)
   #include &amp;quot;BassFunctions.h&amp;quot;
   // Your initialization here....
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And there you have it. No maintenance burden, no typing mistakes, no need to repeat a list of names. With the original BASS header file built the way I propose, you only need 6 lines of code to switch from static to dynamic linking.&lt;/p&gt;

&lt;p&gt;I have used the &amp;#8220;declarator macro + listing include file&amp;#8221; technique quite a few times, in situations well unrelated to DLLs, Windows, Visual C or games altogether, so I guess any C++ programmer can benefit from it. 🙂 For instance, you have a series of enumerated type constants and you want to have them available also in string form (say, to read the constant in string form from a text script file):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// UnitIdList.h
DECLARE_ID(UNITID_SOLDIER)
DECLARE_ID(UNITID_WORKER)
DECLARE_ID(UNITID_MACHINE)
DECLARE_ID(UNITID_RESOURCE)

// UnitId.h
//...
#define DECLARE_ID(a) a,
enum TUnitId
{
#include &amp;quot;UnitIdList.h&amp;quot;
   UNITID_INVALID
};
//...

// somewhere in my cpps...
#include &amp;quot;UnitId.h&amp;quot;

#undef DECLARE_ID
#define DECLARE_ID(a) { a, #a },
static struct { int id; const char *pszId; }
s_aUnitIds[] =
{
#include &amp;quot;UnitIdList.h&amp;quot;
};

TUnitId FindUnitIdFromStringID(const char *pszId)
{
   for (int i = 0; i &amp;lt; ARRAY_LEN(s_aUnitIds); i++)
     if (0 == stricmp(s_aUnitIds[i].pszId, pszId))
       return s_aUnitIds[i].id;
   return UNITID_INVALID;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Windows DLL Interfacing via abstract classes</title>
      <link>https://thejare.github.io/articles/dll-interfaces/</link>
      <pubDate>Sun, 25 Sep 2011 01:56:32 +0000</pubDate>
      
      <guid>https://thejare.github.io/articles/dll-interfaces/</guid>
      <description>&lt;p&gt;Importing functions from a DLL loaded at run-time via ::LoadLibrary() is a cumbersome and error-prone process. You must declare a few pointers to functions, refer to these functions by name, typecast the pointer returned by ::GetProcAddress()&amp;hellip; bah, that may be fine for a couple functions, but when the interface starts to grow, it&amp;rsquo;s a real pain to do. What&amp;rsquo;s more, the DLL may be interested in using some services provided by the loading application, but ::GetProcAddress() can&amp;rsquo;t handle that. Here I present a nice and extremely simple way to do it in C++. Applications that support runtime-loaded plugins are a clear example of this situation; in fact, this technique is inspired by (read: &amp;ldquo;ripped straight out of&amp;rdquo;) the plugin system used it Autodesk&amp;rsquo;s 3DStudio Max modelling package (wait, it&amp;rsquo;s Kinetix&amp;hellip; er, no, it&amp;rsquo;s Discreet. Hm, never mind, by the time you read this it will have changed again).&lt;/p&gt;

&lt;p&gt;The idea is to put all the elements that form the interface to the DLL into an abstract class. This class will be derived by actual DLL instances, which provide the implementation of the interface. The app also provides an similar interface to the DLL. A minimal but fully working example of this can be found in this MSVC++ 6 project. A brief discussion on the technique was held in this Flipcode COTD Article by Justin Blackwell. I have tried to keep the code as simple as possible so there&amp;rsquo;s no real error checking or other niceties.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// --------------
// DLLInterface.h
// --------------

#ifndef __DLLINTERFACE_H__
#define __DLLINTERFACE_H__

// Can&#39;t believe vc doesn&#39;t automate this kind of stuff
#ifdef __DO_DLL_EXPORT__
#define __DLL_FUNCTION__ __declspec(dllexport)
#else
#define __DLL_FUNCTION__ __declspec(dllimport)
#endif

// Interface that the app provides to the DLL
class IAppInterface
{
public:
  virtual int Operation(int parm) = 0;
  // ...
};

// Interface that the DLL provides to the app;
class IDLLInterface
{
public:
  virtual void MyDLLFunction(int parm) = 0;
  // ...
};

extern &amp;quot;C&amp;quot; __DLL_FUNCTION__ IDLLInterface *CreateDLLInterface(IAppInterface *pApp);
typedef IDLLInterface *(*FuncCreateDLLInterface) (IAppInterface *pApp);

#endif //__DLLINTERFACE_H__
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// --------------
// DLL.cpp
// This is compiled as a DLL
// --------------

#include &amp;lt;windows.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

#define __DO_DLL_EXPORT__
#include &amp;quot;DLLInterface.h&amp;quot;

BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved )
{
    return TRUE;
}

// Actual funcionality provided by the DLL.
class CDLLImplementation: public IDLLInterface
{
  IAppInterface *m_pApp;
public:
  CDLLImplementation(IAppInterface *pApp): m_pApp(pApp) { }

  void MyDLLFunction(int parm) { printf(&amp;quot;Yes, %d\n&amp;quot;, m_pApp-&amp;gt;Operation(parm)); }
  // ...
};

IDLLInterface *CreateDLLInterface(IAppInterface *pApp)
{
  static CDLLImplementation dllImpl(pApp);
  return &amp;amp;dllImpl;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// --------------
// App.cpp
// This is compiled as an EXE
// --------------

#include &amp;lt;windows.h&amp;gt;
#include &amp;quot;DLLInterface.h&amp;quot;

// Actual funcionality provided by the app.
class CAppImplementation: public IAppInterface
{
public:
  int Operation(int parm) { return parm*2; }
};

void main()
{
  HMODULE hDLL = ::LoadLibrary(&amp;quot;DLL&amp;quot;);
  FuncCreateDLLInterface createFunc = (FuncCreateDLLInterface)::GetProcAddress(hDLL, &amp;quot;CreateDLLInterface&amp;quot;);

  CAppImplementation App;
  IDLLInterface *pDLL = createFunc(&amp;amp;App);
  pDLL-&amp;gt;MyDLLFunction(10); //Calls the DLL, which in turn calls the app back.
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Main Loop with Fixed Time Steps</title>
      <link>https://thejare.github.io/articles/main-loop-with-fixed-time-steps/</link>
      <pubDate>Sun, 25 Sep 2011 01:38:53 +0000</pubDate>
      
      <guid>https://thejare.github.io/articles/main-loop-with-fixed-time-steps/</guid>
      <description>&lt;p&gt;Note: this article first appeared as a &lt;a href=&#34;http://www.flipcode.com/cgi-bin/msg.cgi?showThread=Tip-MainLoopTimeSteps&amp;amp;#038;forum=totd&amp;amp;#038;id=-1&#34;&gt;Tip Of The Day&lt;/a&gt; in &lt;a href=&#34;http://www.flipcode.com&#34;&gt;Flipcode&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The following description came up during a thread in the SWEng mailing list, and I thought it would make and interesting Tip Of The Day. Thanks to Neil Stewart for his input, and Dave Smith for bringing it up in the first place.&lt;/p&gt;

&lt;p&gt;Most games want to keep a consistent gameplay speed regardless of the framerate achieved by the visuals. Given the wildly varying performance of PC hardware, this is not immediately obvious. The key idea here is the assumption that rendering takes MUCH more time than game logic.&lt;/p&gt;

&lt;p&gt;In our current project, we&amp;#8217;re using a fixed timestep scheme. In the past I have worked with variable timesteps, and somehow always keep coming back to fixed. 🙂 What we do in our main game loop is, essentially:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;time0 = getTickCount();
do
{
  time1 = getTickCount();
  frameTime = 0;
  int numLoops = 0;

  while ((time1 - time0) &amp;gt; TICK_TIME &amp;amp;&amp;amp; numLoops &amp;lt; MAX_LOOPS)
  {
    GameTickRun();
    time0 += TICK_TIME;
    frameTime += TICK_TIME;
    numLoops++;

// Could this be a good idea? We&#39;re not doing it, anyway.
//    time1 = getTickCount();
  }
  IndependentTickRun(frameTime);

  // If playing solo and game logic takes way too long, discard pending
time.
  if (!bNetworkGame &amp;amp;&amp;amp; (time1 - time0) &amp;gt; TICK_TIME)
    time0 = time1 - TICK_TIME;

  if (canRender)
  {
    // Account for numLoops overflow causing percent &amp;gt; 1.

    float percentWithinTick = Min(1.f, float(time1 - time0)/TICK_TIME);
    GameDrawWithInterpolation(percentWithinTick);
  }
}
while (!bGameDone);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;#8217;s examine the main parts:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;while ((time1 - time0) &amp;gt; TICK_TIME &amp;amp;&amp;amp; numLoops &amp;lt; MAX_LOOPS)
{
  GameTickRun();
  time0 += TICK_TIME;
  frameTime += TICK_TIME;
  numLoops++;
  time1 = getTickCount();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The concept behind this is forcing every game logic tick to represent a fixed amount of real-time (real-time is the time shown on your wristwatch). Of course, ticks better take less CPU time to execute, than the real-time it represents. For the record, a variable timestep model would look more like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;GameTickRun(m1-m0); // Each tick represents a varying amount of time.
time0 = time1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I won&amp;#8217;t go in the details &amp;amp; issues of a variable timestep model, although it would make another great TOTD (hint, hint).&lt;/p&gt;

&lt;p&gt;Imagine the following situation: You want to have a ball rolling at a speed of 10 pixels per second (real-time seconds). You have a TICK_TIME of 50 milliseconds (20 ticks per second), which means that every tick, or call to GameTickRun(), the ball should move 0.5 pixels per tick. That&amp;#8217;s the internal speed the game should use for each time it updates the ball&amp;#8217;s position inside the GameTickRun() function.&lt;/p&gt;

&lt;p&gt;No, let&amp;#8217;s say that rendering each frame takes 100 milliseconds, and that updating the ball position takes no time. This means that every time you enter the loop, time1 will be 100 more than time0, therefore the loop will execute twice for each frame rendered (at 10 fps). If each render takes 50 milliseconds (say you got a better videocard), the loop will be done just once and you&amp;#8217;ll be achieving 20 fps. In both cases, you&amp;#8217;ll get your ball moving at 10 pixels per second, the second one with smoother framerate than the first. Remember, we&amp;#8217;re not fixing a framerate, we&amp;#8217;re rendering as fast as our hardware permits, and running the game logic whenever we have to.&lt;/p&gt;

&lt;p&gt;Things get more interesting if we say that we&amp;#8217;re achieving the framerate of 30, therefore each render takes 33.333333333 milliseconds to complete. What do we get? The first time we run the loop after rendering, we find that only 33.33333 milliseconds have elapsed, not enough to fulfill a single game logic tick (TICK_TIME == 50), so we just skip the game logic and render a frame. Next time the time elapsed is 66.666666666, so we run one logic tick and account for the 50 milliseconds a tick represents, thus getting 16.666666666 milliseconds left, and render. Next tick we have 16.66666+33.3333333333 = 50 milliseconds, so we run a tick, get a remainder of 0 milliseconds, render, and go on and on&amp;#8230;&lt;/p&gt;

&lt;p&gt;The real-world situation is that your framerate varies anywhere from 30 to 60 fps for a fast PC game (console games often try to achieve a constant framerate).&lt;/p&gt;

&lt;p&gt;As for the concern that a series of game logic ticks would take more time to execute, than time they represent, that&amp;#8217;s what MAX_LOOPS is for, to limit the amount of ticks executed before rendering. Yes I have seen this happen many times, that&amp;#8217;s why I have added it. If you&amp;#8217;re playing a network game you usually can&amp;#8217;t just slow down the &amp;#8220;game time&amp;#8221; unless all machines do the same, so you can&amp;#8217;t use the MAX_LOOPS guard. (I&amp;#8217;m assuming a lockstep network model)&lt;/p&gt;

&lt;p&gt;I love the separation between frames (visual updates) and ticks (game logic updates), makes everything so simple.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;IndependentTickRun(frameTime);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is where we gather user input and update the whole user interface and perform general housekeeping. 🙂 Things that don&amp;#8217;t need to be run at a precise real-time speed. Since we want our game logic to be perfectly deterministic, the things executed here (or during rendering) must &lt;strong&gt;not&lt;/strong&gt; affect the fixed-step game logic, in any way. In fact we have a run mode where we record the user commands to a file, and we can play back these commands entirely within the timestep loop above. This is an &lt;strong&gt;invaluable&lt;/strong&gt; aid for debugging, and is the basis for the lockstep network model we employ.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;float percentWithinTick = Min(1.f, float(time1 - time0)/TICK_TIME);
GameDrawWithInterpolation(percentWithinTick);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This litte thing allows us to interpolate the positions, orientations, etc of the visuals, in between game ticks. It smooths the visual aliasing caused by a non-constant framerate. Which is the case, because we run a game logic tick 15 times per second (TICK_TIME = &lt;sup&gt;1000&lt;/sup&gt;&amp;frasl;&lt;sub&gt;15&lt;/sub&gt;), while displaying at framerates in the range 20-60 frames per second (fingers crossed).&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>