<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rectangle Packing Code &middot; Jare&#39;s Blog</title>

    <meta name="description" content="">

    <meta name="twitter:card" content="summary">
    
    <meta name="twitter:title" content="Rectangle Packing Code &middot; Jare&#39;s Blog">
    <meta name="twitter:description" content="">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Rectangle Packing Code &middot; Jare&#39;s Blog">
    <meta property="og:description" content="">

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Oxygen:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/pure-min.css">
    <!--[if lte IE 8]>
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-old-ie-min.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-min.css">
    <!--<![endif]-->

    <link rel="stylesheet" href="https://thejare.github.io//css/all.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <link rel="alternate" type="application/rss+xml" title="Jare&#39;s Blog" href="https://thejare.github.io//index.xml" />
</head>
<body>


<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
    <div class="header">
        <hgroup>
            <h1 class="brand-title"><a href="https://thejare.github.io/">Jare&#39;s Blog</a></h1>
            <h2 class="brand-tagline"> Stuff I write </h2>
        </hgroup>

        <p></p>
        <nav class="nav">
            <ul class="nav-list">
                
                <li class="nav-item">
                    <a class="pure-button" href="https://twitter.com/TheJare"><i class="fa fa-twitter"></i> Twitter</a>
                </li>
                
                
                <li class="nav-item">
                    <a class="pure-button" href="https://github.com/TheJare "><i class="fa fa-github-alt"></i> github</a>
                </li>
                
                <li class="nav-item">
                    <a class="pure-button" href="https://thejare.github.io//index.xml"><i class="fa fa-rss"></i> rss</a>
                </li>
            </ul>
        </nav>
        <p></p>
        <nav class="nav">
            <ul class="nav-list">
                
                <li class="menu-item">
                    <a href="../../">Home</a>
                </li>
                
                <li class="menu-item">
                    <a href="../../about-me/">About Me</a>
                </li>
                
                <li class="menu-item">
                    <a href="../../articles/">Articles</a>
                </li>
                
                <li class="menu-item">
                    <a href="../../downloads/">Downloads</a>
                </li>
                
            </ul>
        </nav>
    </div>
</div>


    <div class="content pure-u-1 pure-u-md-3-4">
        <div>
            
            <div class="posts">
                <h1 class="content-subhead">25 Sep 2011, 02:17</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://thejare.github.io/articles/rectangle-packing-code/" class="post-title">Rectangle Packing Code</a>

                        <p class="post-meta">
                            
                                By <strong class="post-author">Jare</strong>
                            
                            
                        </p>
                    </header>
                    
                    <div class="post-description">
                        <p>Note: this article first appeared as a <a href="http://www.flipcode.com/cgi-bin/msg.cgi?showThread=COTD-RectPlacement&amp;#038;forum=cotd&amp;#038;id=-1">Tip Of The Day</a> in <a href="http://www.flipcode.com">Flipcode</a>.</p>

<p>You have a bunch of rectangular pieces. You need to arrange them in a rectangular surface so that they don&rsquo;t overlap, keeping the total area of the rectangle as small as possible. This is fairly common when arranging characters in a bitmapped font, lightmaps for a 3D engine, and I guess other situations as well.</p>

<p>The idea of this algorithm is that, as we add rectangles, we can pre-select &ldquo;interesting&rdquo; places where we can try to add the next rectangles. For optimal results, the rectangles should be added in order. I initially tried using area as a sorting criteria, but it didn&rsquo;t work well with very tall or very flat rectangles. I then tried using the longest dimension as a selector, and it worked much better. So much for intuition &#8230;</p>

<p>These &ldquo;interesting&rdquo; places are just to the right and just below the currently added rectangle. The first rectangle, obviously, goes at the top left, the next one would go either to the right or below this one, and so on. It is a weird way to do it, but it seems to work very nicely.</p>

<p>The way we search here is fairly brute-force, the fact being that for most off-line purposes the performance seems more than adequate. I have generated a japanese font with around 8500 characters and all the time was spent generating the bitmaps.</p>

<p>Also, for all we care, we could grow the parent rectangle in a different way than power of two. It just happens that power of 2 is very convenient for graphics hardware textures.</p>

<p>I&rsquo;d be interested in hearing of other approaches to this problem. Make sure to post them on <a href="http://www.flipcode.com">http://www.flipcode.com</a>.</p>

<p>File: RectPlacement.h</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#aaa;font-style:italic">// --------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic">// Name        : RectPlacement.h
</span><span style="color:#aaa;font-style:italic">// Description : A class that allocates subrectangles into power-of-2 rectangles
</span><span style="color:#aaa;font-style:italic">//               (C) Copyright 2000-2002 by Javier Arevalo
</span><span style="color:#aaa;font-style:italic">//               This code is free to use and modify for all purposes
</span><span style="color:#aaa;font-style:italic">// --------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic"></span>
<span style="color:#4c8317">#ifndef _RECT_PLACEMENT_H_
</span><span style="color:#4c8317">#define _RECT_PLACEMENT_H_
</span><span style="color:#4c8317"></span>

<span style="color:#4c8317">#include</span> <span style="color:#4c8317">&lt;vector&gt;</span><span style="color:#4c8317">
</span><span style="color:#4c8317"></span>
<span style="color:#aaa;font-style:italic">// --------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic">// --------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic"></span>
class CRectPlacement
{
  public:

    <span style="color:#aaa;font-style:italic">// Helper classes
</span><span style="color:#aaa;font-style:italic"></span>    <span style="color:#00a">struct</span> TPos
    {
      <span style="color:#0aa">int</span> x, y;

      TPos() { }
      TPos(<span style="color:#0aa">int</span> _x, <span style="color:#0aa">int</span> _y): x(_x), y(_y) { }

      <span style="color:#0aa">bool</span> operator ==(<span style="color:#00a">const</span> TPos &amp;p) <span style="color:#00a">const</span> { <span style="color:#00a">return</span> x == p.x &amp;&amp; y == p.y; }
    };

    <span style="color:#00a">struct</span> TRect: public TPos
    {
      <span style="color:#0aa">int</span> w, h;

      TRect() { }
      TRect(<span style="color:#0aa">int</span> _x, <span style="color:#0aa">int</span> _y, <span style="color:#0aa">int</span> _w, <span style="color:#0aa">int</span> _h): TPos(_x, _y), w(_w &gt; <span style="color:#099">0</span>? _w : <span style="color:#099">0</span>), h(_h &gt; <span style="color:#099">0</span>? _h : <span style="color:#099">0</span>) { }

      <span style="color:#0aa">bool</span> Contains   (<span style="color:#00a">const</span> TPos &amp;p)  <span style="color:#00a">const</span> { <span style="color:#00a">return</span> (p.x &gt;= x &amp;&amp; p.y &gt;= y &amp;&amp;
                                                       p.x &lt; (x+w) &amp;&amp; p.y &lt; (y+h)); }
      <span style="color:#0aa">bool</span> Contains   (<span style="color:#00a">const</span> TRect &amp;r) <span style="color:#00a">const</span> { <span style="color:#00a">return</span> (r.x &gt;= x &amp;&amp; r.y &gt;= y &amp;&amp;
                                                       (r.x+r.w) &lt;= (x+w) &amp;&amp; (r.y+r.h) &lt;= (y+h)); }
      <span style="color:#0aa">bool</span> Intersects (<span style="color:#00a">const</span> TRect &amp;r) <span style="color:#00a">const</span> { <span style="color:#00a">return</span> w &gt; <span style="color:#099">0</span> &amp;&amp; h &gt; <span style="color:#099">0</span> &amp;&amp; r.w &gt; <span style="color:#099">0</span> &amp;&amp; r.h &gt; <span style="color:#099">0</span> &amp;&amp;
                                                      ((r.x+r.w) &gt; x &amp;&amp; r.x &lt; (x+w) &amp;&amp;
                                                       (r.y+r.h) &gt; y &amp;&amp; r.y &lt; (y+h)); }

    <span style="color:#aaa;font-style:italic">//  Greater rect area. Not as good as the next heuristic
</span><span style="color:#aaa;font-style:italic"></span>    <span style="color:#aaa;font-style:italic">//  static bool Greater(const TRect &amp;a, const TRect &amp;b) { return a.w*a.h &gt; b.w*b.h; }
</span><span style="color:#aaa;font-style:italic"></span>
      <span style="color:#aaa;font-style:italic">// Greater size in at least one dim.
</span><span style="color:#aaa;font-style:italic"></span>      <span style="color:#00a">static</span> <span style="color:#0aa">bool</span> Greater(<span style="color:#00a">const</span> TRect &amp;a, <span style="color:#00a">const</span> TRect &amp;b) { <span style="color:#00a">return</span> (a.w &gt; b.w &amp;&amp; a.w &gt; b.h) ||
                                                                   (a.h &gt; b.w &amp;&amp; a.h &gt; b.h); }
    };

    <span style="color:#aaa;font-style:italic">// ---------------------
</span><span style="color:#aaa;font-style:italic"></span>
    <span style="color:#00a">typedef</span> std::vector&lt;TPos&gt;  CPosArray;
    <span style="color:#00a">typedef</span> std::vector&lt;TRect&gt; CRectArray;

    <span style="color:#aaa;font-style:italic">// ---------------------
</span><span style="color:#aaa;font-style:italic"></span>
    CRectPlacement()                    { Init(); }
    ~CRectPlacement()                   { End(); }

    <span style="color:#0aa">void</span>      Init    (<span style="color:#0aa">int</span> w = <span style="color:#099">1</span>, <span style="color:#0aa">int</span> h = <span style="color:#099">1</span>);
    <span style="color:#0aa">void</span>      <span style="color:#0a0">End</span>     ();
    <span style="color:#0aa">bool</span>      <span style="color:#0a0">IsOk</span>    ()                      <span style="color:#00a">const</span> { <span style="color:#00a">return</span> m_size.w &gt; <span style="color:#099">0</span>; }

    <span style="color:#0aa">int</span>       <span style="color:#0a0">GetW</span>    ()                      <span style="color:#00a">const</span> { <span style="color:#00a">return</span> m_size.w; }
    <span style="color:#0aa">int</span>       <span style="color:#0a0">GetH</span>    ()                      <span style="color:#00a">const</span> { <span style="color:#00a">return</span> m_size.h; }
    <span style="color:#0aa">long</span>      <span style="color:#0a0">GetArea</span> ()                      <span style="color:#00a">const</span> { <span style="color:#00a">return</span> m_area; }
    <span style="color:#0aa">long</span>      <span style="color:#0a0">GetTotalArea</span> ()                 <span style="color:#00a">const</span> { <span style="color:#00a">return</span> m_size.w*m_size.h; }

    <span style="color:#0aa">bool</span> <span style="color:#0a0">AddAtEmptySpotAutoGrow</span> (TRect *pRect, <span style="color:#0aa">int</span> maxW, <span style="color:#0aa">int</span> maxH);

  private:
    TRect       m_size;
    CRectArray  m_vRects;
    CPosArray   m_vPositions;
    <span style="color:#0aa">long</span>        m_area;

    <span style="color:#aaa;font-style:italic">// ---------------------
</span><span style="color:#aaa;font-style:italic"></span>
    <span style="color:#0aa">bool</span> <span style="color:#0a0">IsFree</span>                 (<span style="color:#00a">const</span> TRect &amp;r) <span style="color:#00a">const</span>;
    <span style="color:#0aa">void</span> <span style="color:#0a0">AddPosition</span>            (<span style="color:#00a">const</span> TPos &amp;p);
    <span style="color:#0aa">void</span> <span style="color:#0a0">AddRect</span>                (<span style="color:#00a">const</span> TRect &amp;r);
    <span style="color:#0aa">bool</span> <span style="color:#0a0">AddAtEmptySpot</span>         (TRect &amp;r);
};


<span style="color:#4c8317">#endif //_RECT_PLACEMENT_H_</span></code></pre></div>
<p>File: RectPlacement.cpp</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#aaa;font-style:italic">// ----------------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic">// Name        : RectPlacement.cpp
</span><span style="color:#aaa;font-style:italic">// Description : A class that fits subrectangles into a power-of-2 rectangle
</span><span style="color:#aaa;font-style:italic">//               (C) Copyright 2000-2002 by Javier Arevalo
</span><span style="color:#aaa;font-style:italic">//               This code is free to use and modify for all purposes
</span><span style="color:#aaa;font-style:italic">// ----------------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic"></span>
<span style="color:#aaa;font-style:italic">/*
</span><span style="color:#aaa;font-style:italic">  You have a bunch of rectangular pieces. You need to arrange them in a 
</span><span style="color:#aaa;font-style:italic">  rectangular surface so that they don&#39;t overlap, keeping the total area of the 
</span><span style="color:#aaa;font-style:italic">  rectangle as small as possible. This is fairly common when arranging characters 
</span><span style="color:#aaa;font-style:italic">  in a bitmapped font, lightmaps for a 3D engine, and I guess other situations as 
</span><span style="color:#aaa;font-style:italic">  well.
</span><span style="color:#aaa;font-style:italic">
</span><span style="color:#aaa;font-style:italic">  The idea of this algorithm is that, as we add rectangles, we can pre-select 
</span><span style="color:#aaa;font-style:italic">  &#34;interesting&#34; places where we can try to add the next rectangles. For optimal 
</span><span style="color:#aaa;font-style:italic">  results, the rectangles should be added in order. I initially tried using area 
</span><span style="color:#aaa;font-style:italic">  as a sorting criteria, but it didn&#39;t work well with very tall or very flat 
</span><span style="color:#aaa;font-style:italic">  rectangles. I then tried using the longest dimension as a selector, and it 
</span><span style="color:#aaa;font-style:italic">  worked much better. So much for intuition...
</span><span style="color:#aaa;font-style:italic">
</span><span style="color:#aaa;font-style:italic">  These &#34;interesting&#34; places are just to the right and just below the currently 
</span><span style="color:#aaa;font-style:italic">  added rectangle. The first rectangle, obviously, goes at the top left, the next 
</span><span style="color:#aaa;font-style:italic">  one would go either to the right or below this one, and so on. It is a weird way 
</span><span style="color:#aaa;font-style:italic">  to do it, but it seems to work very nicely.
</span><span style="color:#aaa;font-style:italic">
</span><span style="color:#aaa;font-style:italic">  The way we search here is fairly brute-force, the fact being that for most off-
</span><span style="color:#aaa;font-style:italic">  line purposes the performance seems more than adequate. I have generated a 
</span><span style="color:#aaa;font-style:italic">  japanese font with around 8500 characters and all the time was spent generating 
</span><span style="color:#aaa;font-style:italic">  the bitmaps.
</span><span style="color:#aaa;font-style:italic">
</span><span style="color:#aaa;font-style:italic">  Also, for all we care, we could grow the parent rectangle in a different way 
</span><span style="color:#aaa;font-style:italic">  than power of two. It just happens that power of 2 is very convenient for 
</span><span style="color:#aaa;font-style:italic">  graphics hardware textures.
</span><span style="color:#aaa;font-style:italic">
</span><span style="color:#aaa;font-style:italic">  I&#39;d be interested in hearing of other approaches to this problem. Make sure
</span><span style="color:#aaa;font-style:italic">  to post them on http://www.flipcode.com
</span><span style="color:#aaa;font-style:italic">*/</span>

<span style="color:#4c8317">#include</span> <span style="color:#4c8317">&#34;RectPlacement.h&#34;</span><span style="color:#4c8317">
</span><span style="color:#4c8317"></span>
<span style="color:#aaa;font-style:italic">// --------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic">// Name        : 
</span><span style="color:#aaa;font-style:italic">// Description : 
</span><span style="color:#aaa;font-style:italic">// --------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#0aa">void</span> CRectPlacement::Init    (<span style="color:#0aa">int</span> w, <span style="color:#0aa">int</span> h)
{
  End();
  m_size = TRect(<span style="color:#099">0</span>, <span style="color:#099">0</span>, w, h);
  m_vPositions.push_back(TPos(<span style="color:#099">0</span>,<span style="color:#099">0</span>));
  m_area = <span style="color:#099">0</span>;
}


<span style="color:#aaa;font-style:italic">// --------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic">// Name        : 
</span><span style="color:#aaa;font-style:italic">// Description : 
</span><span style="color:#aaa;font-style:italic">// --------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#0aa">void</span> CRectPlacement::End     ()
{
  m_vPositions.clear();
  m_vRects.clear();
  m_size.w = <span style="color:#099">0</span>;
}

<span style="color:#aaa;font-style:italic">// --------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic">// Name        : IsFree
</span><span style="color:#aaa;font-style:italic">// Description : Check if the given rectangle is partially or totally used
</span><span style="color:#aaa;font-style:italic">// --------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#0aa">bool</span> CRectPlacement::IsFree (<span style="color:#00a">const</span> TRect &amp;r) <span style="color:#00a">const</span>
{
  <span style="color:#00a">if</span> (!m_size.Contains(r))
    <span style="color:#00a">return</span> <span style="color:#0aa">false</span>;
  <span style="color:#00a">for</span> (CRectArray::const_iterator it = m_vRects.begin();
       it != m_vRects.end();
       ++it)
    <span style="color:#00a">if</span> (it-&gt;Intersects(r))
      <span style="color:#00a">return</span> <span style="color:#0aa">false</span>;
  <span style="color:#00a">return</span> <span style="color:#0aa">true</span>;
}


<span style="color:#aaa;font-style:italic">// --------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic">// Name        : AddPosition
</span><span style="color:#aaa;font-style:italic">// Description : Add new anchor point
</span><span style="color:#aaa;font-style:italic">// --------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#0aa">void</span> CRectPlacement::AddPosition    (<span style="color:#00a">const</span> TPos &amp;p)
{
  <span style="color:#aaa;font-style:italic">// Try to insert anchor as close as possible to the top left corner
</span><span style="color:#aaa;font-style:italic"></span>  <span style="color:#aaa;font-style:italic">// So it will be tried first
</span><span style="color:#aaa;font-style:italic"></span>  <span style="color:#0aa">bool</span> bFound = <span style="color:#0aa">false</span>;
  CPosArray::iterator it;
  <span style="color:#00a">for</span> (it = m_vPositions.begin();
       !bFound &amp;&amp; it != m_vPositions.end();
       ++it)
  {
    <span style="color:#00a">if</span> (p.x+p.y &lt; it-&gt;x+it-&gt;y)
      bFound = <span style="color:#0aa">true</span>;
  }
  <span style="color:#00a">if</span> (bFound)
    m_vPositions.insert(it, p);
  <span style="color:#00a">else</span>

    m_vPositions.push_back(p);
}

<span style="color:#aaa;font-style:italic">// --------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic">// Name        : AddRect
</span><span style="color:#aaa;font-style:italic">// Description : Add the given rect and updates anchor points
</span><span style="color:#aaa;font-style:italic">// --------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#0aa">void</span> CRectPlacement::AddRect  (<span style="color:#00a">const</span> TRect &amp;r)
{
  m_vRects.push_back(r);
  m_area += r.w*r.h;

  <span style="color:#aaa;font-style:italic">// Add two new anchor points
</span><span style="color:#aaa;font-style:italic"></span>  AddPosition(TPos(r.x, r.y+r.h));
  AddPosition(TPos(r.x+r.w, r.y));
}

<span style="color:#aaa;font-style:italic">// --------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic">// Name        : AddAtEmptySpot
</span><span style="color:#aaa;font-style:italic">// Description : Add the given rectangle
</span><span style="color:#aaa;font-style:italic">// --------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#0aa">bool</span> CRectPlacement::AddAtEmptySpot   (TRect &amp;r)
{
  <span style="color:#aaa;font-style:italic">// Find a valid spot among available anchors.
</span><span style="color:#aaa;font-style:italic"></span>
  <span style="color:#0aa">bool</span> bFound = <span style="color:#0aa">false</span>;
  CPosArray::iterator it;
  <span style="color:#00a">for</span> (it = m_vPositions.begin();
       !bFound &amp;&amp; it != m_vPositions.end();
       ++it)
  {
    TRect Rect(it-&gt;x, it-&gt;y, r.w, r.h);

    <span style="color:#00a">if</span> (IsFree(Rect))
    {
      r = Rect;
      bFound = <span style="color:#0aa">true</span>;
      <span style="color:#00a">break</span>; <span style="color:#aaa;font-style:italic">// Don&#39;t let the loop increase the iterator.
</span><span style="color:#aaa;font-style:italic"></span>    }
  }
  <span style="color:#00a">if</span> (bFound)
  {
    <span style="color:#aaa;font-style:italic">// Remove the used anchor point
</span><span style="color:#aaa;font-style:italic"></span>    m_vPositions.erase(it);

    <span style="color:#aaa;font-style:italic">// Sometimes, anchors end up displaced from the optimal position
</span><span style="color:#aaa;font-style:italic"></span>    <span style="color:#aaa;font-style:italic">// due to irregular sizes of the subrects.
</span><span style="color:#aaa;font-style:italic"></span>    <span style="color:#aaa;font-style:italic">// So, try to adjut it up &amp; left as much as possible.
</span><span style="color:#aaa;font-style:italic"></span>    <span style="color:#00a">for</span> (<span style="color:#0aa">int</span> x = <span style="color:#099">1</span>; x &lt;= r.x; x++)
      <span style="color:#00a">if</span> (!IsFree(TRect(r.x - x, r.y, r.w, r.h)))
        <span style="color:#00a">break</span>;
    <span style="color:#00a">for</span> (<span style="color:#0aa">int</span> y = <span style="color:#099">1</span>; y &lt;= r.y; y++)
      <span style="color:#00a">if</span> (!IsFree(TRect(r.x, r.y - y, r.w, r.h)))
        <span style="color:#00a">break</span>;
    <span style="color:#00a">if</span> (y &gt; x)
      r.y -= y-<span style="color:#099">1</span>;
    <span style="color:#00a">else</span>

      r.x -= x-<span style="color:#099">1</span>;
    AddRect(r);
  }
  <span style="color:#00a">return</span> bFound;
}


<span style="color:#aaa;font-style:italic">// --------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic">// Name        : AddAtEmptySpotAutoGrow
</span><span style="color:#aaa;font-style:italic">// Description : Add a rectangle of the given size, growing our area if needed
</span><span style="color:#aaa;font-style:italic">//               Area grows only until the max given.
</span><span style="color:#aaa;font-style:italic">//               Returns the placement of the rect in the rect&#39;s x,y coords
</span><span style="color:#aaa;font-style:italic">// --------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic"></span>
<span style="color:#0aa">bool</span> CRectPlacement::AddAtEmptySpotAutoGrow   (TRect *pRect, <span style="color:#0aa">int</span> maxW, <span style="color:#0aa">int</span> maxH)
{
  <span style="color:#00a">if</span> (pRect-&gt;w &lt;= <span style="color:#099">0</span>)
    <span style="color:#00a">return</span> <span style="color:#0aa">true</span>;

  <span style="color:#0aa">int</span> orgW = m_size.w;
  <span style="color:#0aa">int</span> orgH = m_size.h;

  <span style="color:#aaa;font-style:italic">// Try to add it in the existing space
</span><span style="color:#aaa;font-style:italic"></span>  <span style="color:#00a">while</span> (!AddAtEmptySpot(*pRect))
  {
    <span style="color:#0aa">int</span> pw = m_size.w;
    <span style="color:#0aa">int</span> ph = m_size.h;

    <span style="color:#aaa;font-style:italic">// Sanity check - if area is complete.
</span><span style="color:#aaa;font-style:italic"></span>    <span style="color:#00a">if</span> (pw &gt;= maxW &amp;&amp; ph &gt;= maxH)
    {
      m_size.w = orgW;
      m_size.h = orgH;
      <span style="color:#00a">return</span> <span style="color:#0aa">false</span>;
    }

    <span style="color:#aaa;font-style:italic">// Try growing the smallest dim
</span><span style="color:#aaa;font-style:italic"></span>    <span style="color:#00a">if</span> (pw &lt; maxW &amp;&amp; (pw &lt; ph || ((pw == ph) &amp;&amp; (pRect-&gt;w &gt;= pRect-&gt;h))))
      m_size.w = pw*<span style="color:#099">2</span>;
    <span style="color:#00a">else</span>
      m_size.h = ph*<span style="color:#099">2</span>;
    <span style="color:#00a">if</span> (AddAtEmptySpot(*pRect))
      <span style="color:#00a">break</span>;

    <span style="color:#aaa;font-style:italic">// Try growing the other dim instead
</span><span style="color:#aaa;font-style:italic"></span>    <span style="color:#00a">if</span> (pw != m_size.w)
    {
      m_size.w = pw;
      <span style="color:#00a">if</span> (ph &lt; maxW)
        m_size.h = ph*<span style="color:#099">2</span>;
    }
    <span style="color:#00a">else</span>
    {
      m_size.h = ph;
      <span style="color:#00a">if</span> (pw &lt; maxW)
        m_size.w = pw*<span style="color:#099">2</span>;
    }

    <span style="color:#00a">if</span> (pw != m_size.w || ph != m_size.h)
      <span style="color:#00a">if</span> (AddAtEmptySpot(*pRect))
        <span style="color:#00a">break</span>;

    <span style="color:#aaa;font-style:italic">// Grow both if possible, and reloop.
</span><span style="color:#aaa;font-style:italic"></span>    m_size.w = pw;
    m_size.h = ph;
    <span style="color:#00a">if</span> (pw &lt; maxW)
      m_size.w = pw*<span style="color:#099">2</span>;
    <span style="color:#00a">if</span> (ph &lt; maxH)
      m_size.h = ph*<span style="color:#099">2</span>;
  }
  <span style="color:#00a">return</span> <span style="color:#0aa">true</span>;
}</code></pre></div>
<p>File: Test.cpp</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#aaa;font-style:italic">// ----------------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic">// Name        : Test.cpp
</span><span style="color:#aaa;font-style:italic">// Description : Test the RectPlacement class
</span><span style="color:#aaa;font-style:italic">//               (C) Copyright 2000-2002 by Javier Arevalo
</span><span style="color:#aaa;font-style:italic">//               This code is free to use and modify for all purposes
</span><span style="color:#aaa;font-style:italic">// ----------------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic"></span>
<span style="color:#4c8317">#include</span> <span style="color:#4c8317">&lt;stdio.h&gt;</span><span style="color:#4c8317">
</span><span style="color:#4c8317">#include</span> <span style="color:#4c8317">&lt;algorithm&gt;</span><span style="color:#4c8317">
</span><span style="color:#4c8317"></span>
<span style="color:#4c8317">#include</span> <span style="color:#4c8317">&#34;RectPlacement.h&#34;</span><span style="color:#4c8317">
</span><span style="color:#4c8317"></span>
<span style="color:#4c8317">#define MAX_TEXTURE_W 256
</span><span style="color:#4c8317">#define MAX_TEXTURE_H 256
</span><span style="color:#4c8317"></span>
<span style="color:#4c8317">#define NUM_SUBRECTS  500
</span><span style="color:#4c8317">#define MIN_SUBRECT    15
</span><span style="color:#4c8317">#define MAX_SUBRECT    50
</span><span style="color:#4c8317"></span>

<span style="color:#aaa;font-style:italic">// --------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic">// --------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic"></span>
<span style="color:#00a">struct</span> TSubRect: public CRectPlacement::TRect
{
  <span style="color:#0aa">int</span> n;      <span style="color:#aaa;font-style:italic">// Original index of this subrect, before sorting
</span><span style="color:#aaa;font-style:italic"></span>  <span style="color:#0aa">int</span> nTex;   <span style="color:#aaa;font-style:italic">// Texture in which this subrect will be placed.
</span><span style="color:#aaa;font-style:italic"></span>
  TSubRect() { }
  TSubRect(<span style="color:#0aa">int</span> _w, <span style="color:#0aa">int</span> _h, <span style="color:#0aa">int</span> _n): TRect(<span style="color:#099">0</span>, <span style="color:#099">0</span>, _w, _h), n(_n), nTex(<span style="color:#099">0</span>) { }
};

<span style="color:#aaa;font-style:italic">// --------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic">// --------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic"></span>
<span style="color:#00a">typedef</span> std::vector&lt;TSubRect&gt;       CSubRectArray;
<span style="color:#00a">typedef</span> std::vector&lt;CRectPlacement&gt; CTextureArray;

<span style="color:#aaa;font-style:italic">// --------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic">// Name        : CreateLetters
</span><span style="color:#aaa;font-style:italic">// Description : Here&#39;s where you calculate your rectangles,
</span><span style="color:#aaa;font-style:italic">// --------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic"></span>
<span style="color:#0aa">void</span> <span style="color:#0a0">CreateLetters</span>  (CSubRectArray &amp;vecSubRects)
{
  vecSubRects.clear();

  <span style="color:#aaa;font-style:italic">// Let&#39;s just fill this with random stuff
</span><span style="color:#aaa;font-style:italic"></span>  <span style="color:#00a">for</span> (<span style="color:#0aa">int</span> i = <span style="color:#099">0</span>; i &lt; NUM_SUBRECTS; i++)
    vecSubRects.push_back(TSubRect((rand() % MAX_SUBRECT) + MIN_SUBRECT,
                                   (rand() % MAX_SUBRECT) + MIN_SUBRECT, i));
}

<span style="color:#aaa;font-style:italic">// --------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic">// Name        : CreateTextures
</span><span style="color:#aaa;font-style:italic">// Description : Create array of textures containing all subrects
</span><span style="color:#aaa;font-style:italic">// --------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#0aa">void</span> <span style="color:#0a0">CreateTextures</span> (CTextureArray &amp;vecTextures, CSubRectArray &amp;vecSubRects, <span style="color:#0aa">int</span> maxTexW, <span style="color:#0aa">int</span> maxTexH)
{
  <span style="color:#aaa;font-style:italic">// Sort the subRects based on dimensions, larger dimension goes first.
</span><span style="color:#aaa;font-style:italic"></span>  std::sort(vecSubRects.begin(), vecSubRects.end(), CRectPlacement::TRect::Greater);

  <span style="color:#aaa;font-style:italic">// Generate the first texture
</span><span style="color:#aaa;font-style:italic"></span>  vecTextures.clear();
  vecTextures.push_back(CRectPlacement());

  <span style="color:#aaa;font-style:italic">// Add all subrects
</span><span style="color:#aaa;font-style:italic"></span>  <span style="color:#00a">for</span> (CSubRectArray::iterator it = vecSubRects.begin();
       it != vecSubRects.end();
       ++it)
  {
    <span style="color:#aaa;font-style:italic">// We make sure we leave one pixel between subrects, so texels don&#39;t bleed with bilinear.
</span><span style="color:#aaa;font-style:italic"></span>    CRectPlacement::TRect r(<span style="color:#099">0</span>, <span style="color:#099">0</span>, it-&gt;w+<span style="color:#099">1</span>, it-&gt;h+<span style="color:#099">1</span>);

    <span style="color:#aaa;font-style:italic">// If an existing texture has actual space
</span><span style="color:#aaa;font-style:italic"></span>    <span style="color:#0aa">bool</span> bPlaced = <span style="color:#0aa">false</span>;
    <span style="color:#00a">for</span> (<span style="color:#0aa">int</span> i = <span style="color:#099">0</span>; !bPlaced &amp;&amp; i &lt; vecTextures.size(); i++)
    {
      bPlaced = vecTextures[i].AddAtEmptySpotAutoGrow(&amp;r, maxTexW, maxTexH);
      <span style="color:#00a">if</span> (bPlaced)
        it-&gt;nTex = i;
    }

    <span style="color:#aaa;font-style:italic">// Try starting a new texture and fit the rect in there
</span><span style="color:#aaa;font-style:italic"></span>    <span style="color:#00a">if</span> (!bPlaced)
    {
      vecTextures.push_back(CRectPlacement());
      bPlaced = vecTextures[vecTextures.size()-<span style="color:#099">1</span>].AddAtEmptySpotAutoGrow(&amp;r, maxTexW, maxTexH);
      <span style="color:#00a">if</span> (bPlaced)
        it-&gt;nTex = vecTextures.size()-<span style="color:#099">1</span>;
      <span style="color:#00a">else</span>
        printf(<span style="color:#a50"></span><span style="color:#a50">&#34;ERROR: Subrect is too big to fit in texture!&#34;</span>, it-&gt;w, it-&gt;h);
    }

    <span style="color:#aaa;font-style:italic">// If correctly placed in a texture, the coords are returned in r.x and r.y
</span><span style="color:#aaa;font-style:italic"></span>    <span style="color:#aaa;font-style:italic">// Store them.
</span><span style="color:#aaa;font-style:italic"></span>    <span style="color:#00a">if</span> (bPlaced)
    {
      it-&gt;x = r.x;
      it-&gt;y = r.y;
    }
  }
}

<span style="color:#aaa;font-style:italic">// --------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic">// Name        : main
</span><span style="color:#aaa;font-style:italic">// Description : heh
</span><span style="color:#aaa;font-style:italic">// --------------------------------------------------------------------------------
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#0aa">int</span> <span style="color:#0a0">main</span>()
{
  CTextureArray vecTextures;
  CSubRectArray vecSubRects;

  CreateLetters(vecSubRects);
  CreateTextures(vecTextures, vecSubRects, MAX_TEXTURE_W, MAX_TEXTURE_H);

  {
    <span style="color:#00a">for</span> (CSubRectArray::const_iterator it = vecSubRects.begin();
         it != vecSubRects.end();
         ++it)
    {
      printf(<span style="color:#a50"></span><span style="color:#a50">&#34;Subrect %d (originally %d), size %dx%d, goes into texture %d at pos %d,%d</span><span style="color:#a50">\n</span><span style="color:#a50">&#34;</span>,
             it - vecSubRects.begin(), it-&gt;n, it-&gt;w, it-&gt;h, it-&gt;nTex, it-&gt;x, it-&gt;y);
    }
  }

  printf(<span style="color:#a50"></span><span style="color:#a50">&#34;Created a total of %d textures</span><span style="color:#a50">\n</span><span style="color:#a50">&#34;</span>, vecTextures.size());
  {
    <span style="color:#00a">for</span> (CTextureArray::const_iterator it = vecTextures.begin();
         it != vecTextures.end();
         ++it)
    {
      printf(<span style="color:#a50"></span><span style="color:#a50">&#34;  Texture %d, size %dx%d, Coverage %d / %d (%d%%)</span><span style="color:#a50">\n</span><span style="color:#a50">&#34;</span>,
             it - vecTextures.begin(), it-&gt;GetW(), it-&gt;GetH(),
             it-&gt;GetArea(), it-&gt;GetTotalArea(), it-&gt;GetArea()*<span style="color:#099">100</span>/it-&gt;GetTotalArea());
    }
  }
  <span style="color:#00a">return</span> <span style="color:#099">0</span>;
}</code></pre></div>
                    </div>
                    
                </section>
            </div>
            <div class="footer">
    <div class="pure-menu pure-menu-horizontal pure-menu-open">
        <ul>
            <li>Powered by <a class="hugo" href="http://hugo.spf13.com/" target="_blank">hugo</a>. Theme is based on <a class="hugo" href="https://github.com/dplesca/purehugo">Purehugo</a> by Dragos Plesca</li>
        </ul>
    </div>
</div>
<script src="https://thejare.github.io//js/all.min.js"></script>
        </div>
    </div>
</div>


<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', '', 'auto');
ga('send', 'pageview');

</script>

</body>
</html>
